<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keywords" content="">
    <meta name="author" content="">

    <title>Uvicorn</title>

    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,300,600' rel='stylesheet' type='text/css'>
    <link href="./css/toolkit.css" rel="stylesheet">
    <link href="./css/docs.css" rel="stylesheet">
    <link href="./css/application.css" rel="stylesheet">
    <link href="./css/highlight.css" rel="stylesheet">
    <link rel="icon" href="./img/favicon.png?v=2" type="image/x-icon">
    <style>
      pre {
          background-color: #fff;
          border-color: #d3e0e9;
          padding: 20px;
          margin-right: 0;
          margin-left: 0;
          margin-bottom: 20px;
          border: 1px solid #e5e5e5;
          border-radius: 3px;
      }
    </style>

  </head>


<body class="with-top-navbar">

<nav class="navbar navbar-toggleable-sm fixed-top navbar-inverse bg-primary app-navbar">
    <nav class="container">
  <button
    class="navbar-toggler navbar-toggler-right hidden-md-up"
    type="button"
    data-toggle="collapse"
    data-target="#navbarResponsive"
    aria-controls="navbarResponsive"
    aria-expanded="false"
    aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <a class="navbar-brand" href="/">
    ðŸ¦„
  </a>

  <div class="collapse navbar-collapse" id="navbarResponsive">
    <ul class="navbar-nav mr-auto">
      <li class="nav-item active">
        <a class="nav-link" href="/">Documentation</a>
      </li>
    </ul>

    <ul class="nav navbar-nav float-right mr-0 hidden-sm-down">
      <li class="nav-item">
          <a class="nav-link" href="https://github.com/tomchristie/uvicorn">
              <i class="fa fa-github"></i> GitHub</a>
      </li>
    </ul>
  </div>
  </nav>
</nav>

</div>


    <div class="docs-header" id="content">
      <div class="container">
        <h1>Uvicorn</h1>
        <p>The lightning-fast asyncio server, for Python 3.</p>
      </div>
    </div>


<div class="container docs-content">

<h1 id="contents">Contents</h1>

<ul id="markdown-toc">
    <li><a href="#introduction">Introduction</a>
        <ul>
        <li><a href="#quickstart">Quickstart</a></li>
        </ul>
    </li>
        <li><a href="#introduction">Introduction</a><ul>
            <li><a href="#quickstart">Quickstart</a></li>
        </ul>
        </li>
        <li><a href="#messaging-interface">Messaging interface</a>
        </li>
        <li><a href="#http">HTTP</a><ul>
            <li><a href="#requests-responses">Requests &amp; responses</a></li>
            <li><a href="#reading-the-request-body">Reading the request body</a></li>
            <li><a href="#streaming-responses">Streaming responses</a></li>
        </ul>
        </li>
        <li><a href="#websockets">WebSockets</a><ul>
            <li><a href="#incoming-outgoing-data">Incoming &amp; outgoing data</a></li>
            <li><a href="#connects-disconnects">Connects &amp; disconnects</a></li>
        </ul>
        </li>
        <li><a href="#broadcast">Broadcast</a><ul>
            <li><a href="#commands">Commands</a></li>
            <li><a href="#example">Example</a></li>
        </ul>
        </li>
        <li><a href="#adapters">Adapters</a><ul>
            <li><a href="#asgiadapter">ASGIAdapter</a></li>
            <li><a href="#wsgiadapter">WSGIAdapter</a></li>
        </ul>
        </li>
</ul>

<h1 id="introduction">Introduction</h1>
<p>Uvicorn is intended to be the basis for providing Python 3 with a simple
interface on which to build asyncio web frameworks. It provides the following:</p>
<ul>
<li>A lightning-fast asyncio server implementation, using <a href="https://github.com/MagicStack/uvloop">uvloop</a> and <a href="https://github.com/MagicStack/httptools">httptools</a>.</li>
<li>A minimal application interface, based on <a href="http://channels.readthedocs.io/en/stable/asgi.html">ASGI</a>.</li>
</ul>
<h2 id="quickstart">Quickstart</h2>
<p>Requirements: Python 3.5.3+</p>
<p>Install using <code>pip</code>:</p>
<pre><code class="shell">$ pip install uvicorn
</code></pre>

<p>Create an application, in <code>app.py</code>:</p>
<pre><code class="python">async def hello_world(message, channels):
    content = b'Hello, world'
    response = {
        'status': 200,
        'headers': [
            [b'content-type', b'text/plain'],
        ],
        'content': content
    }
    await channels['reply'].send(response)
</code></pre>

<p>Run the server:</p>
<pre><code class="shell">$ uvicorn app:hello_world
</code></pre>

<h1 id="messaging-interface">Messaging interface</h1>
<p>Uvicorn introduces a messaging interface broadly based on ASGI...</p>
<p>The application should expose a coroutine callable which takes two arguments:</p>
<ul>
<li><code>message</code> is an <a href="http://channels.readthedocs.io/en/stable/asgi/www.html#http-websocket-asgi-message-format-draft-spec">ASGI message</a>.  (But see below for ammendments.)</li>
<li><code>channels</code> is a dictionary of <code>&lt;unicode string&gt;:&lt;channel interface&gt;</code>.</li>
</ul>
<p>The channel interface is an object with the following attributes:</p>
<ul>
<li><code>.send(message)</code> - A coroutine for sending outbound messages. Optional.</li>
<li><code>.receive()</code> - A coroutine for receiving incoming messages. Optional.</li>
<li><code>.name</code> - A unicode string, uniquely identifying the channel. Optional.</li>
</ul>
<p>Messages diverge from ASGI in the following ways:</p>
<ul>
<li>Messages additionally include a <code>channel</code> key, to allow for routing eg. <code>'channel': 'http.request'</code></li>
<li>Messages do not include channel names, such as <code>reply_channel</code> or <code>body_channel</code>,
  instead the <code>channels</code> dictionary presents the available channels.</li>
</ul>
<h1 id="http">HTTP</h1>
<p>The format for HTTP request and response messages is described in <a href="http://channels.readthedocs.io/en/stable/asgi/www.html#http">the ASGI documentation</a>.</p>
<h2 id="requests-responses">Requests &amp; responses</h2>
<p>Here's an example that displays the method and path used in the incoming request:</p>
<pre><code class="python">async def echo_method_and_path(message, channels):
    body = 'Received %s request to %s' % (message['method'], message['path'])
    response = {
        'status': 200,
        'headers': [
            [b'content-type', b'text/plain'],
        ],
        'content': body.encode('utf-8')
    }
    await channels['reply'].send(response)
</code></pre>

<h2 id="reading-the-request-body">Reading the request body</h2>
<p>You can stream the request body without blocking the asyncio task pool,
by receiving <a href="http://channels.readthedocs.io/en/stable/asgi/www.html#request-body-chunk">request body chunks</a> from the <code>body</code> channel.</p>
<pre><code class="python">async def read_body(message, channels):
    &quot;&quot;&quot;
    Read and return the entire body from an incoming ASGI message.
    &quot;&quot;&quot;
    body = message.get('body', b'')
    if 'body' in channels:
        while True:
            message_chunk = await channels['body'].receive()
            body += message_chunk['content']
            if not message_chunk.get('more_content', False):
                break
    return body


async def echo_body(message, channels):
    body = await read_body(message, channels)
    response = {
        'status': 200,
        'headers': [
            [b'content-type', b'text/plain'],
        ],
        'content': body
    }
    await channels['reply'].send(response)
</code></pre>

<h2 id="streaming-responses">Streaming responses</h2>
<p>You can stream responses by sending <a href="http://channels.readthedocs.io/en/stable/asgi/www.html#response-chunk">response chunks</a> to the
<code>reply</code> channel:</p>
<pre><code class="python">async def stream_response(message, channels):
    # Send the start of the response.
    await channels['reply'].send({
        'status': 200,
        'headers': [
            [b'content-type', b'text/plain'],
        ],
        'content': b'',
        'more_content': True
    })

    # Stream response content.
    for chunk in [b'Hello', b', ', b'world']:
        await channels['reply'].send({
            'content': chunk,
            'more_content': True
        })

    # End the response.
    await channels['reply'].send({
        'content': b'',
        'more_content': False
    })
</code></pre>

<h1 id="websockets">WebSockets</h1>
<p>Uvicorn supports websockets, using the same messaging interface described
above, with <a href="http://channels.readthedocs.io/en/latest/asgi/www.html#websocket">ASGI WebSocket messages</a>.</p>
<h2 id="incoming-outgoing-data">Incoming &amp; outgoing data</h2>
<p>We'll start with an example that simply echos any incoming websocket messages
back to the client.</p>
<pre><code class="python">async def echo(message, channels):
    if message['channel'] == 'websocket.receive':
        text = message['text']
        await channels['reply'].send({
            'text': text
        })
</code></pre>

<p>Another example, this time demonstrating a websocket connection that sends
back the current time to each connected client, roughly once per second.</p>
<pre><code class="python">import datetime
import asyncio


async def send_times(channel):
    while True:
        text = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        await channel.send({'text': text})
        await asyncio.sleep(1)


async def tick(message, channels):
    if message['channel'] == 'websocket.connect':
        loop = asyncio.get_event_loop()
        loop.create_task(send_times(channels['reply']))
</code></pre>

<h2 id="connects-disconnects">Connects &amp; disconnects</h2>
<p>Connect and disconnect messages allow you to keep track of connected clients.</p>
<p>Here's a more complete example that demonstrates a basic WebSocket chat server:</p>
<p><strong>index.html</strong>:</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;WebSocket demo&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;WebSocket Chat&lt;/h1&gt;
        &lt;form action=&quot;&quot; onsubmit=&quot;sendMessage(event)&quot;&gt;
            &lt;input type=&quot;text&quot; id=&quot;messageText&quot; autocomplete=&quot;off&quot;/&gt;
            &lt;button&gt;Send&lt;/button&gt;
        &lt;/form&gt;
        &lt;ul id='messages'&gt;
        &lt;/ul&gt;
        &lt;script&gt;
            var ws = new WebSocket(&quot;ws://127.0.0.1:8000/&quot;);

            ws.onmessage = function(event) {
                var messages = document.getElementById('messages')
                var message = document.createElement('li')
                var content = document.createTextNode(event.data)
                message.appendChild(content)
                messages.appendChild(message)
            };

            function sendMessage(event) {
                var input = document.getElementById(&quot;messageText&quot;)
                ws.send(input.value)
                input.value = ''
                event.preventDefault()
            }
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p><strong>app.py</strong>:</p>
<pre><code class="python">clients = set()
with open('index.html', 'rb') as file:
    homepage = file.read()

async def chat_server(message, channels):
    &quot;&quot;&quot;
    ASGI-style 'Hello, world' application.
    &quot;&quot;&quot;
    if message['channel'] == 'websocket.connect':
        clients.add(channels['reply'])

    elif message['channel'] == 'websocket.receive':
        for client in clients:
            await client.send({'text': message['text']})

    elif message['channel'] == 'websocket.disconnect':
        clients.remove(channels['reply'])

    elif message['channel'] == 'http.request':
        await channels['reply'].send({
            'status': 200,
            'headers': [
                [b'content-type', b'text/html'],
            ],
            'content': homepage
        })
</code></pre>

<p>Note that the example above will only work properly when running as a single
process on a single machine, since the set of connected clients is stored in
memory.</p>
<p>In order to build properly scalable WebSocket services you'll typically want
some way of sending messages across a group of client connections, each of
which may be connected to a different server instance...</p>
<h1 id="broadcast">Broadcast</h1>
<p>Uvicorn includes broadcast functionality, using Redis Pub/Sub.</p>
<p>First, make sure to install the <code>asyncio_redis</code> package:</p>
<pre><code class="shell">$ pip install asyncio_redis
</code></pre>

<p>Broadcast functionality is not integrated directly into the server, but is
included as application-level middleware. You can install the broadcast module
by wrapping it around your existing application, like so:</p>
<pre><code class="python">from uvicorn.broadcast import BroadCastMiddleware

async def my_app(messages, channels):
    ...

app = BroadCastMiddleware(my_app, 'localhost', 6379)
</code></pre>

<h2 id="commands">Commands</h2>
<p>Including the broadcast middleware will make a <code>groups</code> channel available,
which accepts the following command messages:</p>
<h3 id="add">Add</h3>
<pre><code class="python">await channels['groups'].send({
    'group': &lt;name&gt;,
    'add': &lt;channel_name&gt;
})
</code></pre>

<p>Add a channel to the given group.</p>
<h3 id="discard">Discard</h3>
<pre><code class="python">await channels['groups'].send({
    'group': &lt;name&gt;,
    'discard': &lt;channel_name&gt;
})
</code></pre>

<p>Remove a channel from the given group.</p>
<h3 id="send">Send</h3>
<pre><code class="python">await channels['groups'].send({
    'group': &lt;name&gt;,
    'send': &lt;message&gt;
})
</code></pre>

<p>Send a message to all channels in the given group.</p>
<h2 id="example">Example</h2>
<p>Let's add broadcast functionality to our previous chat server example...</p>
<pre><code class="python">from uvicorn.broadcast import BroadcastMiddleware


with open('index.html', 'rb') as file:
    homepage = file.read()


async def chat_server(message, channels):
    &quot;&quot;&quot;
    A WebSocket based chat server.
    &quot;&quot;&quot;
    if message['channel'] == 'websocket.connect':
        await channels['groups'].send({
            'group': 'chat',
            'add': channels['reply'].name
        })

    elif message['channel'] == 'websocket.receive':
        await channels['groups'].send({
            'group': 'chat',
            'send': {'text': message['text']}
        })

    elif message['channel'] == 'websocket.disconnect':
        await channels['groups'].send({
            'group': 'chat',
            'discard': channels['reply'].name
        })

    elif message['channel'] == 'http.request':
        await channels['reply'].send({
            'status': 200,
            'headers': [
                [b'content-type', b'text/html'],
            ],
            'content': homepage
        })


chat_server = BroadcastMiddleware(chat_server)
</code></pre>

<p>We can now start up a connected group of chat server instances:</p>
<p>First, start a Redis server:</p>
<pre><code class="shell">$ redis-server
</code></pre>

<p>Then start one or more Uvicorn instances:</p>
<pre><code class="shell">$ uvicorn app:chat_server --bind 127.0.0.1:8000
$ uvicorn app:chat_server --bind 127.0.0.1:8001
$ uvicorn app:chat_server --bind 127.0.0.1:8002
</code></pre>

<p>You can now open multiple browser windows, each connected to a different
server instance, and send chat messages between them.</p>
<h1 id="adapters">Adapters</h1>
<h2 id="asgiadapter">ASGIAdapter</h2>
<p>Provides an ASGI-style interface for an existing WSGI application.</p>
<pre><code class="python">from uvicorn.utils import ASGIAdapter

def app(environ, start_response):
    ...

asgi = ASGIAdapter(app)
</code></pre>

<h2 id="wsgiadapter">WSGIAdapter</h2>
<p>Provides a WSGI interface for an existing ASGI-style application.</p>
<p>Useful if you're writing an asyncio application, but want to provide
a backwards-compatibility interface for WSGI.</p>
<pre><code class="python">from uvicorn.utils import WSGIAdapter

async def app(message, channels):
    ...

wsgi = WSGIAdapter(app)
</code></pre>

      <a class="docs-top" style="display: none" href="#">Back to top</a>
    </div>


    <script src="./js/jquery.min.js"></script>
    <script src="./js/tether.min.js"></script>
    <script src="./js/chart.js"></script>
    <script src="./js/toolkit.js"></script>
    <script src="./js/application.js"></script>
    <script src="./js/highlight.pack.js"></script>
    <script>
      $(document).ready(function() {
          hljs.initHighlightingOnLoad();
      })
    </script>
  </body>
</html>