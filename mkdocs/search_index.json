{
    "docs": [
        {
            "location": "/",
            "text": "Introduction\n\n\nPython currently lacks a minimal low-level server/application interface for\nasyncio frameworks. Filling this gap means we'd be able to start building\na common set of tooling usable across all asyncio frameworks.\n\n\nUvicorn is an attempt to resolve this, by providing:\n\n\n\n\nA lightning-fast asyncio server implementation, using \nuvloop\n and \nhttptools\n.\n\n\nA minimal application interface, based on \nASGI\n.\n\n\n\n\nIt currently supports HTTP, WebSockets, Pub/Sub broadcast, and is open\nto extension to other protocols & messaging styles.\n\n\nQuickstart\n\n\nRequirements: Python 3.5.3+\n\n\nInstall using \npip\n:\n\n\n$ pip install uvicorn\n\n\n\n\nCreate an application, in \napp.py\n:\n\n\nasync def hello_world(message, channels):\n    content = b'Hello, world'\n    response = {\n        'status': 200,\n        'headers': [\n            [b'content-type', b'text/plain'],\n        ],\n        'content': content\n    }\n    await channels['reply'].send(response)\n\n\n\n\nRun the server:\n\n\n$ uvicorn app:hello_world\n\n\n\n\nMessaging interface\n\n\nUvicorn introduces a messaging interface broadly based on \nASGI\n...\n\n\nThe application should expose a coroutine callable which takes two arguments:\n\n\n\n\nmessage\n is an \nASGI message\n.  (But see below for ammendments.)\n\n\nchannels\n is a dictionary of \n<unicode string>:<channel interface>\n.\n\n\n\n\nThe channel interface is an object with the following attributes:\n\n\n\n\n.send(message)\n - A coroutine for sending outbound messages. Optional.\n\n\n.receive()\n - A coroutine for receiving incoming messages. Optional.\n\n\n.name\n - A unicode string, uniquely identifying the channel. Optional.\n\n\n\n\nMessages diverge from ASGI in the following ways:\n\n\n\n\nMessages additionally include a \nchannel\n key, to allow for routing eg. \n'channel': 'http.request'\n\n\nMessages do not include channel names, such as \nreply_channel\n or \nbody_channel\n,\n  instead the \nchannels\n dictionary presents the available channels.\n\n\n\n\nExample\n\n\nAn incoming HTTP request might be represented with the following \nmessage\n\nand \nchannels\n information:\n\n\nmessage\n:\n\n\n{\n    'channel': 'http.request',\n    'scheme': 'http',\n    'root_path': '',\n    'server': ('127.0.0.1', 8000),\n    'http_version': '1.1',\n    'method': 'GET',\n    'path': '/',\n    'headers': [\n        [b'host', b'127.0.0.1:8000'],\n        [b'user-agent', b'curl/7.51.0'],\n        [b'accept', b'*/*']\n    ]\n}\n\n\n\n\nchannels\n:\n\n\n{\n    'reply': <ReplyChannel>\n}\n\n\n\n\nIn order to respond, the application would \nsend()\n an HTTP response to\nthe reply channel, for instance:\n\n\nawait channels['reply'].send({\n    'status': 200,\n    'headers': [\n        [b'content-type', b'text/plain'],\n    ],\n    'content': b'Hello, world'\n})\n\n\n\n\nHTTP\n\n\nThe format for HTTP request and response messages is described in \nthe ASGI documentation\n.\n\n\nRequests & responses\n\n\nHere's an example that displays the method and path used in the incoming request:\n\n\nasync def echo_method_and_path(message, channels):\n    body = 'Received %s request to %s' % (message['method'], message['path'])\n    response = {\n        'status': 200,\n        'headers': [\n            [b'content-type', b'text/plain'],\n        ],\n        'content': body.encode('utf-8')\n    }\n    await channels['reply'].send(response)\n\n\n\n\nReading the request body\n\n\nYou can stream the request body without blocking the asyncio task pool,\nby receiving \nrequest body chunks\n from the \nbody\n channel.\n\n\nasync def read_body(message, channels):\n    \"\"\"\n    Read and return the entire body from an incoming ASGI message.\n    \"\"\"\n    body = message.get('body', b'')\n    if 'body' in channels:\n        while True:\n            message_chunk = await channels['body'].receive()\n            body += message_chunk['content']\n            if not message_chunk.get('more_content', False):\n                break\n    return body\n\n\nasync def echo_body(message, channels):\n    body = await read_body(message, channels)\n    response = {\n        'status': 200,\n        'headers': [\n            [b'content-type', b'text/plain'],\n        ],\n        'content': body\n    }\n    await channels['reply'].send(response)\n\n\n\n\nStreaming responses\n\n\nYou can stream responses by sending \nresponse chunks\n to the\n\nreply\n channel:\n\n\nasync def stream_response(message, channels):\n    # Send the start of the response.\n    await channels['reply'].send({\n        'status': 200,\n        'headers': [\n            [b'content-type', b'text/plain'],\n        ],\n        'content': b'',\n        'more_content': True\n    })\n\n    # Stream response content.\n    for chunk in [b'Hello', b', ', b'world']:\n        await channels['reply'].send({\n            'content': chunk,\n            'more_content': True\n        })\n\n    # End the response.\n    await channels['reply'].send({\n        'content': b'',\n        'more_content': False\n    })\n\n\n\n\nWebSockets\n\n\nUvicorn supports websockets, using the same messaging interface described\nabove, with \nASGI WebSocket messages\n.\n\n\nIncoming & outgoing data\n\n\nWe'll start with an example that simply echos any incoming websocket messages\nback to the client.\n\n\nasync def echo(message, channels):\n    if message['channel'] == 'websocket.receive':\n        text = message['text']\n        await channels['reply'].send({\n            'text': text\n        })\n\n\n\n\nAnother example, this time demonstrating a websocket connection that sends\nback the current time to each connected client, roughly once per second.\n\n\nimport datetime\nimport asyncio\n\n\nasync def send_times(channel):\n    while True:\n        text = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n        await channel.send({'text': text})\n        await asyncio.sleep(1)\n\n\nasync def tick(message, channels):\n    if message['channel'] == 'websocket.connect':\n        loop = asyncio.get_event_loop()\n        loop.create_task(send_times(channels['reply']))\n\n\n\n\nConnects & disconnects\n\n\nConnect and disconnect messages allow you to keep track of connected clients.\n\n\nHere's a more complete example that demonstrates a basic WebSocket chat server:\n\n\nindex.html\n:\n\n\n<!DOCTYPE html>\n<html>\n    <head>\n        <title>WebSocket demo</title>\n    </head>\n    <body>\n        <h1>WebSocket Chat</h1>\n        <form action=\"\" onsubmit=\"sendMessage(event)\">\n            <input type=\"text\" id=\"messageText\" autocomplete=\"off\"/>\n            <button>Send</button>\n        </form>\n        <ul id='messages'>\n        </ul>\n        <script>\n            var ws = new WebSocket(\"ws://127.0.0.1:8000/\");\n\n            ws.onmessage = function(event) {\n                var messages = document.getElementById('messages')\n                var message = document.createElement('li')\n                var content = document.createTextNode(event.data)\n                message.appendChild(content)\n                messages.appendChild(message)\n            };\n\n            function sendMessage(event) {\n                var input = document.getElementById(\"messageText\")\n                ws.send(input.value)\n                input.value = ''\n                event.preventDefault()\n            }\n        </script>\n    </body>\n</html>\n\n\n\n\napp.py\n:\n\n\nclients = set()\nwith open('index.html', 'rb') as file:\n    homepage = file.read()\n\nasync def chat_server(message, channels):\n    \"\"\"\n    ASGI-style 'Hello, world' application.\n    \"\"\"\n    if message['channel'] == 'websocket.connect':\n        clients.add(channels['reply'])\n\n    elif message['channel'] == 'websocket.receive':\n        for client in clients:\n            await client.send({'text': message['text']})\n\n    elif message['channel'] == 'websocket.disconnect':\n        clients.remove(channels['reply'])\n\n    elif message['channel'] == 'http.request':\n        await channels['reply'].send({\n            'status': 200,\n            'headers': [\n                [b'content-type', b'text/html'],\n            ],\n            'content': homepage\n        })\n\n\n\n\nNote that the example above will only work properly when running as a single\nprocess on a single machine, since the set of connected clients is stored in\nmemory.\n\n\nIn order to build properly scalable WebSocket services you'll typically want\nsome way of sending messages across a group of client connections, each of\nwhich may be connected to a different server instance...\n\n\nBroadcast\n\n\nUvicorn includes broadcast functionality, using Redis Pub/Sub.\n\n\nFirst, make sure to install the \nasyncio_redis\n package:\n\n\n$ pip install asyncio_redis\n\n\n\n\nBroadcast functionality is not integrated directly into the server, but is\nincluded as application-level middleware. You can install the broadcast module\nby wrapping it around your existing application, like so:\n\n\nfrom uvicorn.broadcast import BroadCastMiddleware\n\nasync def my_app(messages, channels):\n    ...\n\napp = BroadCastMiddleware(my_app, 'localhost', 6379)\n\n\n\n\nCommands\n\n\nIncluding the broadcast middleware will make a \ngroups\n channel available,\nwhich accepts the following command messages:\n\n\nAdd\n\n\nawait channels['groups'].send({\n    'group': <name>,\n    'add': <channel_name>\n})\n\n\n\n\nAdd a channel to the given group.\n\n\nDiscard\n\n\nawait channels['groups'].send({\n    'group': <name>,\n    'discard': <channel_name>\n})\n\n\n\n\nRemove a channel from the given group.\n\n\nSend\n\n\nawait channels['groups'].send({\n    'group': <name>,\n    'send': <message>\n})\n\n\n\n\nSend a message to all channels in the given group.\n\n\nExample\n\n\nLet's add broadcast functionality to our previous chat server example...\n\n\nfrom uvicorn.broadcast import BroadcastMiddleware\n\n\nwith open('index.html', 'rb') as file:\n    homepage = file.read()\n\n\nasync def chat_server(message, channels):\n    \"\"\"\n    A WebSocket based chat server.\n    \"\"\"\n    if message['channel'] == 'websocket.connect':\n        await channels['groups'].send({\n            'group': 'chat',\n            'add': channels['reply'].name\n        })\n\n    elif message['channel'] == 'websocket.receive':\n        await channels['groups'].send({\n            'group': 'chat',\n            'send': {'text': message['text']}\n        })\n\n    elif message['channel'] == 'websocket.disconnect':\n        await channels['groups'].send({\n            'group': 'chat',\n            'discard': channels['reply'].name\n        })\n\n    elif message['channel'] == 'http.request':\n        await channels['reply'].send({\n            'status': 200,\n            'headers': [\n                [b'content-type', b'text/html'],\n            ],\n            'content': homepage\n        })\n\n\nchat_server = BroadcastMiddleware(chat_server)\n\n\n\n\nWe can now start up a connected group of chat server instances:\n\n\nFirst, start a Redis server:\n\n\n$ redis-server\n\n\n\n\nThen start one or more Uvicorn instances:\n\n\n$ uvicorn app:chat_server --bind 127.0.0.1:8000\n$ uvicorn app:chat_server --bind 127.0.0.1:8001\n$ uvicorn app:chat_server --bind 127.0.0.1:8002\n\n\n\n\nYou can now open multiple browser windows, each connected to a different\nserver instance, and send chat messages between them.\n\n\nAdapters\n\n\nASGIAdapter\n\n\nProvides an ASGI-style interface for an existing WSGI application.\n\n\nfrom uvicorn.utils import ASGIAdapter\n\ndef app(environ, start_response):\n    ...\n\nasgi = ASGIAdapter(app)\n\n\n\n\nWSGIAdapter\n\n\nProvides a WSGI interface for an existing ASGI-style application.\n\n\nUseful if you're writing an asyncio application, but want to provide\na backwards-compatibility interface for WSGI.\n\n\nfrom uvicorn.utils import WSGIAdapter\n\nasync def app(message, channels):\n    ...\n\nwsgi = WSGIAdapter(app)",
            "title": "Home"
        },
        {
            "location": "/#introduction",
            "text": "Python currently lacks a minimal low-level server/application interface for\nasyncio frameworks. Filling this gap means we'd be able to start building\na common set of tooling usable across all asyncio frameworks.  Uvicorn is an attempt to resolve this, by providing:   A lightning-fast asyncio server implementation, using  uvloop  and  httptools .  A minimal application interface, based on  ASGI .   It currently supports HTTP, WebSockets, Pub/Sub broadcast, and is open\nto extension to other protocols & messaging styles.",
            "title": "Introduction"
        },
        {
            "location": "/#quickstart",
            "text": "Requirements: Python 3.5.3+  Install using  pip :  $ pip install uvicorn  Create an application, in  app.py :  async def hello_world(message, channels):\n    content = b'Hello, world'\n    response = {\n        'status': 200,\n        'headers': [\n            [b'content-type', b'text/plain'],\n        ],\n        'content': content\n    }\n    await channels['reply'].send(response)  Run the server:  $ uvicorn app:hello_world",
            "title": "Quickstart"
        },
        {
            "location": "/#messaging-interface",
            "text": "Uvicorn introduces a messaging interface broadly based on  ASGI ...  The application should expose a coroutine callable which takes two arguments:   message  is an  ASGI message .  (But see below for ammendments.)  channels  is a dictionary of  <unicode string>:<channel interface> .   The channel interface is an object with the following attributes:   .send(message)  - A coroutine for sending outbound messages. Optional.  .receive()  - A coroutine for receiving incoming messages. Optional.  .name  - A unicode string, uniquely identifying the channel. Optional.   Messages diverge from ASGI in the following ways:   Messages additionally include a  channel  key, to allow for routing eg.  'channel': 'http.request'  Messages do not include channel names, such as  reply_channel  or  body_channel ,\n  instead the  channels  dictionary presents the available channels.",
            "title": "Messaging interface"
        },
        {
            "location": "/#example",
            "text": "An incoming HTTP request might be represented with the following  message \nand  channels  information:  message :  {\n    'channel': 'http.request',\n    'scheme': 'http',\n    'root_path': '',\n    'server': ('127.0.0.1', 8000),\n    'http_version': '1.1',\n    'method': 'GET',\n    'path': '/',\n    'headers': [\n        [b'host', b'127.0.0.1:8000'],\n        [b'user-agent', b'curl/7.51.0'],\n        [b'accept', b'*/*']\n    ]\n}  channels :  {\n    'reply': <ReplyChannel>\n}  In order to respond, the application would  send()  an HTTP response to\nthe reply channel, for instance:  await channels['reply'].send({\n    'status': 200,\n    'headers': [\n        [b'content-type', b'text/plain'],\n    ],\n    'content': b'Hello, world'\n})",
            "title": "Example"
        },
        {
            "location": "/#http",
            "text": "The format for HTTP request and response messages is described in  the ASGI documentation .",
            "title": "HTTP"
        },
        {
            "location": "/#requests-responses",
            "text": "Here's an example that displays the method and path used in the incoming request:  async def echo_method_and_path(message, channels):\n    body = 'Received %s request to %s' % (message['method'], message['path'])\n    response = {\n        'status': 200,\n        'headers': [\n            [b'content-type', b'text/plain'],\n        ],\n        'content': body.encode('utf-8')\n    }\n    await channels['reply'].send(response)",
            "title": "Requests &amp; responses"
        },
        {
            "location": "/#reading-the-request-body",
            "text": "You can stream the request body without blocking the asyncio task pool,\nby receiving  request body chunks  from the  body  channel.  async def read_body(message, channels):\n    \"\"\"\n    Read and return the entire body from an incoming ASGI message.\n    \"\"\"\n    body = message.get('body', b'')\n    if 'body' in channels:\n        while True:\n            message_chunk = await channels['body'].receive()\n            body += message_chunk['content']\n            if not message_chunk.get('more_content', False):\n                break\n    return body\n\n\nasync def echo_body(message, channels):\n    body = await read_body(message, channels)\n    response = {\n        'status': 200,\n        'headers': [\n            [b'content-type', b'text/plain'],\n        ],\n        'content': body\n    }\n    await channels['reply'].send(response)",
            "title": "Reading the request body"
        },
        {
            "location": "/#streaming-responses",
            "text": "You can stream responses by sending  response chunks  to the reply  channel:  async def stream_response(message, channels):\n    # Send the start of the response.\n    await channels['reply'].send({\n        'status': 200,\n        'headers': [\n            [b'content-type', b'text/plain'],\n        ],\n        'content': b'',\n        'more_content': True\n    })\n\n    # Stream response content.\n    for chunk in [b'Hello', b', ', b'world']:\n        await channels['reply'].send({\n            'content': chunk,\n            'more_content': True\n        })\n\n    # End the response.\n    await channels['reply'].send({\n        'content': b'',\n        'more_content': False\n    })",
            "title": "Streaming responses"
        },
        {
            "location": "/#websockets",
            "text": "Uvicorn supports websockets, using the same messaging interface described\nabove, with  ASGI WebSocket messages .",
            "title": "WebSockets"
        },
        {
            "location": "/#incoming-outgoing-data",
            "text": "We'll start with an example that simply echos any incoming websocket messages\nback to the client.  async def echo(message, channels):\n    if message['channel'] == 'websocket.receive':\n        text = message['text']\n        await channels['reply'].send({\n            'text': text\n        })  Another example, this time demonstrating a websocket connection that sends\nback the current time to each connected client, roughly once per second.  import datetime\nimport asyncio\n\n\nasync def send_times(channel):\n    while True:\n        text = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n        await channel.send({'text': text})\n        await asyncio.sleep(1)\n\n\nasync def tick(message, channels):\n    if message['channel'] == 'websocket.connect':\n        loop = asyncio.get_event_loop()\n        loop.create_task(send_times(channels['reply']))",
            "title": "Incoming &amp; outgoing data"
        },
        {
            "location": "/#connects-disconnects",
            "text": "Connect and disconnect messages allow you to keep track of connected clients.  Here's a more complete example that demonstrates a basic WebSocket chat server:  index.html :  <!DOCTYPE html>\n<html>\n    <head>\n        <title>WebSocket demo</title>\n    </head>\n    <body>\n        <h1>WebSocket Chat</h1>\n        <form action=\"\" onsubmit=\"sendMessage(event)\">\n            <input type=\"text\" id=\"messageText\" autocomplete=\"off\"/>\n            <button>Send</button>\n        </form>\n        <ul id='messages'>\n        </ul>\n        <script>\n            var ws = new WebSocket(\"ws://127.0.0.1:8000/\");\n\n            ws.onmessage = function(event) {\n                var messages = document.getElementById('messages')\n                var message = document.createElement('li')\n                var content = document.createTextNode(event.data)\n                message.appendChild(content)\n                messages.appendChild(message)\n            };\n\n            function sendMessage(event) {\n                var input = document.getElementById(\"messageText\")\n                ws.send(input.value)\n                input.value = ''\n                event.preventDefault()\n            }\n        </script>\n    </body>\n</html>  app.py :  clients = set()\nwith open('index.html', 'rb') as file:\n    homepage = file.read()\n\nasync def chat_server(message, channels):\n    \"\"\"\n    ASGI-style 'Hello, world' application.\n    \"\"\"\n    if message['channel'] == 'websocket.connect':\n        clients.add(channels['reply'])\n\n    elif message['channel'] == 'websocket.receive':\n        for client in clients:\n            await client.send({'text': message['text']})\n\n    elif message['channel'] == 'websocket.disconnect':\n        clients.remove(channels['reply'])\n\n    elif message['channel'] == 'http.request':\n        await channels['reply'].send({\n            'status': 200,\n            'headers': [\n                [b'content-type', b'text/html'],\n            ],\n            'content': homepage\n        })  Note that the example above will only work properly when running as a single\nprocess on a single machine, since the set of connected clients is stored in\nmemory.  In order to build properly scalable WebSocket services you'll typically want\nsome way of sending messages across a group of client connections, each of\nwhich may be connected to a different server instance...",
            "title": "Connects &amp; disconnects"
        },
        {
            "location": "/#broadcast",
            "text": "Uvicorn includes broadcast functionality, using Redis Pub/Sub.  First, make sure to install the  asyncio_redis  package:  $ pip install asyncio_redis  Broadcast functionality is not integrated directly into the server, but is\nincluded as application-level middleware. You can install the broadcast module\nby wrapping it around your existing application, like so:  from uvicorn.broadcast import BroadCastMiddleware\n\nasync def my_app(messages, channels):\n    ...\n\napp = BroadCastMiddleware(my_app, 'localhost', 6379)",
            "title": "Broadcast"
        },
        {
            "location": "/#commands",
            "text": "Including the broadcast middleware will make a  groups  channel available,\nwhich accepts the following command messages:",
            "title": "Commands"
        },
        {
            "location": "/#add",
            "text": "await channels['groups'].send({\n    'group': <name>,\n    'add': <channel_name>\n})  Add a channel to the given group.",
            "title": "Add"
        },
        {
            "location": "/#discard",
            "text": "await channels['groups'].send({\n    'group': <name>,\n    'discard': <channel_name>\n})  Remove a channel from the given group.",
            "title": "Discard"
        },
        {
            "location": "/#send",
            "text": "await channels['groups'].send({\n    'group': <name>,\n    'send': <message>\n})  Send a message to all channels in the given group.",
            "title": "Send"
        },
        {
            "location": "/#example_1",
            "text": "Let's add broadcast functionality to our previous chat server example...  from uvicorn.broadcast import BroadcastMiddleware\n\n\nwith open('index.html', 'rb') as file:\n    homepage = file.read()\n\n\nasync def chat_server(message, channels):\n    \"\"\"\n    A WebSocket based chat server.\n    \"\"\"\n    if message['channel'] == 'websocket.connect':\n        await channels['groups'].send({\n            'group': 'chat',\n            'add': channels['reply'].name\n        })\n\n    elif message['channel'] == 'websocket.receive':\n        await channels['groups'].send({\n            'group': 'chat',\n            'send': {'text': message['text']}\n        })\n\n    elif message['channel'] == 'websocket.disconnect':\n        await channels['groups'].send({\n            'group': 'chat',\n            'discard': channels['reply'].name\n        })\n\n    elif message['channel'] == 'http.request':\n        await channels['reply'].send({\n            'status': 200,\n            'headers': [\n                [b'content-type', b'text/html'],\n            ],\n            'content': homepage\n        })\n\n\nchat_server = BroadcastMiddleware(chat_server)  We can now start up a connected group of chat server instances:  First, start a Redis server:  $ redis-server  Then start one or more Uvicorn instances:  $ uvicorn app:chat_server --bind 127.0.0.1:8000\n$ uvicorn app:chat_server --bind 127.0.0.1:8001\n$ uvicorn app:chat_server --bind 127.0.0.1:8002  You can now open multiple browser windows, each connected to a different\nserver instance, and send chat messages between them.",
            "title": "Example"
        },
        {
            "location": "/#adapters",
            "text": "",
            "title": "Adapters"
        },
        {
            "location": "/#asgiadapter",
            "text": "Provides an ASGI-style interface for an existing WSGI application.  from uvicorn.utils import ASGIAdapter\n\ndef app(environ, start_response):\n    ...\n\nasgi = ASGIAdapter(app)",
            "title": "ASGIAdapter"
        },
        {
            "location": "/#wsgiadapter",
            "text": "Provides a WSGI interface for an existing ASGI-style application.  Useful if you're writing an asyncio application, but want to provide\na backwards-compatibility interface for WSGI.  from uvicorn.utils import WSGIAdapter\n\nasync def app(message, channels):\n    ...\n\nwsgi = WSGIAdapter(app)",
            "title": "WSGIAdapter"
        }
    ]
}