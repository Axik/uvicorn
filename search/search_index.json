{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nUvicorn is a lightning-fast ASGI server, built on \nuvloop\n and \nhttptools\n.\n\n\nUntil recently Python has lacked a minimal low-level server/application interface for\nasyncio frameworks. The \nASGI specification\n fills this gap, and means we're now able to start building\na common set of tooling usable across all asyncio frameworks.\n\n\nASGI should help enable an ecosystem of Python web frameworks that are highly competitive against Node\nand Go in terms of achieving high throughput in IO-bound contexts. It also provides support for HTTP/2 and\nWebSockets, which cannot be handled by WSGI.\n\n\nUvicorn currently supports HTTP/1.1 and WebSockets. Support for HTTP/2 is planned.\n\n\nQuickstart\n\n\nRequirements: Python 3.5.3+\n\n\nInstall using \npip\n:\n\n\n$ pip install uvicorn\n\n\n\n\nCreate an application, in \napp.py\n:\n\n\nclass App():\n    def __init__(self, scope):\n        self.scope = scope\n\n    async def __call__(self, receive, send):\n        await send({\n            'type': 'http.response.start',\n            'status': 200,\n            'headers': [\n                [b'content-type', b'text/plain'],\n            ]\n        })\n        await send({\n            'type': 'http.response.body',\n            'body': b'Hello, world!',\n        })\n\n\n\n\nRun the server:\n\n\n$ uvicorn app:App\n\n\n\n\nThe ASGI interface\n\n\nUvicorn uses the \nASGI specification\n for interacting with an application.\n\n\nThe application should expose a callable which takes one argument, \nscope\n.\nThis callable is used to create a new instance of the application for each incoming connection.\nIt must return a coroutine which the server can then call into.\n\n\nThe application instance coroutine takes two arguments, \n(recieve, send)\n,\nwhich are the channels by which messages are sent between the web server and client application.\n\n\nOne style of implementation is to use a class with an \n__init__()\n method to handle\napplication instantiation, and a \n__call__()\n coroutine to provide the application implementation.\n\n\nclass App():\n    def __init__(self, scope):\n        self.scope = scope\n\n    async def __call__(self, receive, send):\n        ...\n\n\n\n\nThe content of the \nscope\n argument, and the messages expected by \nrecieve\n and \nsend\n depend on\nthe protocol being used.\n\n\nThe format for HTTP messages is described in the \nASGI HTTP Message format\n.\n\n\nHTTP Scope\n\n\nAn incoming HTTP request might instantiate an application with the following \nscope\n:\n\n\n{\n    'type': 'http.request',\n    'scheme': 'http',\n    'root_path': '',\n    'server': ('127.0.0.1', 8000),\n    'http_version': '1.1',\n    'method': 'GET',\n    'path': '/',\n    'headers': [\n        [b'host', b'127.0.0.1:8000'],\n        [b'user-agent', b'curl/7.51.0'],\n        [b'accept', b'*/*']\n    ]\n}\n\n\n\n\nHTTP Messages\n\n\nThe instance coroutine communicates back to the server by sending messages to the \nsend\n coroutine.\n\n\nawait send({\n    'type': 'http.request.start',\n    'status': 200,\n    'headers': [\n        [b'content-type', b'text/plain'],\n    ]\n})\nawait send({\n    'type': 'http.request.body',\n    'body': b'Hello, world!',\n})\n\n\n\n\nRequests \n responses\n\n\nHere's an example that displays the method and path used in the incoming request:\n\n\nclass EchoMethodAndPath():\n    def __init__(self, scope):\n        self.scope = scope\n\n    async def __call__(self, recieve, send):\n        body = 'Received %s request to %s' % (self.scope['method'], self.scope['path'])\n        await send({\n            'http.response.start',\n            'status': 200,\n            'headers': [\n                [b'content-type', b'text/plain'],\n            ]\n        })\n        await send({\n            'type': 'http.response.body',\n            'body': body.encode('utf-8'),\n        })\n\n\n\n\nReading the request body\n\n\nYou can stream the request body without blocking the asyncio task pool,\nby fetching messages from the \nreceive\n coroutine.\n\n\nclass EchoBody():\n    def __init__(self, scope):\n        self.scope = scope\n\n    async def read_body(self, receive):\n        \n\n        Read and return the entire body from an incoming ASGI message.\n        \n\n        body = b''\n        more_body = True\n\n        while more_body:\n            message = await receive()\n            body += message.get('body', b'')\n            more_body = message.get('more_body', False)\n\n        return body\n\n\n    async def __call__(self, receive, send):\n        body = await self.read_body(receive)\n        await send({\n            'http.response.start',\n            'status': 200,\n            'headers': [\n                [b'content-type', b'text/plain'],\n            ]\n        })\n        await send({\n            'type': 'http.response.body',\n            'body': body,\n        })\n\n\n\n\nStreaming responses\n\n\nYou can stream responses by sending multiple \nhttp.response.body\n messages to\nthe \nsend\n coroutine.\n\n\nclass StreamResponse():\n    def __init__(self, scope):\n        self.scope = scope\n\n    async def __call__(self, receive, send):\n        body = await self.read_body(receive)\n        await send({\n            'http.response.start',\n            'status': 200,\n            'headers': [\n                [b'content-type', b'text/plain'],\n            ]\n        })\n        for chunk in [b'Hello', b', ', b'world!']\n            await send({\n                'type': 'http.response.body',\n                'body': chunk,\n                'more_body': True\n            })\n        await send({\n            'type': 'http.response.body',\n            'body': b'',\n        })\n\n\n\n\n\n\nAlternative ASGI servers\n\n\nThe first ASGI server implementation, originally developed to power Django Channels,\nis \nthe Daphne webserver\n.\n\n\nIt is run widely in production, and supports HTTP/1.1, HTTP/2, and WebSockets.\n\n\nAny of the example applications given here can equally well be run using \ndaphne\n instead.\n\n\n$ pip install daphne\n$ daphne app:App", 
            "title": "Home"
        }, 
        {
            "location": "/#introduction", 
            "text": "Uvicorn is a lightning-fast ASGI server, built on  uvloop  and  httptools .  Until recently Python has lacked a minimal low-level server/application interface for\nasyncio frameworks. The  ASGI specification  fills this gap, and means we're now able to start building\na common set of tooling usable across all asyncio frameworks.  ASGI should help enable an ecosystem of Python web frameworks that are highly competitive against Node\nand Go in terms of achieving high throughput in IO-bound contexts. It also provides support for HTTP/2 and\nWebSockets, which cannot be handled by WSGI.  Uvicorn currently supports HTTP/1.1 and WebSockets. Support for HTTP/2 is planned.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#quickstart", 
            "text": "Requirements: Python 3.5.3+  Install using  pip :  $ pip install uvicorn  Create an application, in  app.py :  class App():\n    def __init__(self, scope):\n        self.scope = scope\n\n    async def __call__(self, receive, send):\n        await send({\n            'type': 'http.response.start',\n            'status': 200,\n            'headers': [\n                [b'content-type', b'text/plain'],\n            ]\n        })\n        await send({\n            'type': 'http.response.body',\n            'body': b'Hello, world!',\n        })  Run the server:  $ uvicorn app:App", 
            "title": "Quickstart"
        }, 
        {
            "location": "/#the-asgi-interface", 
            "text": "Uvicorn uses the  ASGI specification  for interacting with an application.  The application should expose a callable which takes one argument,  scope .\nThis callable is used to create a new instance of the application for each incoming connection.\nIt must return a coroutine which the server can then call into.  The application instance coroutine takes two arguments,  (recieve, send) ,\nwhich are the channels by which messages are sent between the web server and client application.  One style of implementation is to use a class with an  __init__()  method to handle\napplication instantiation, and a  __call__()  coroutine to provide the application implementation.  class App():\n    def __init__(self, scope):\n        self.scope = scope\n\n    async def __call__(self, receive, send):\n        ...  The content of the  scope  argument, and the messages expected by  recieve  and  send  depend on\nthe protocol being used.  The format for HTTP messages is described in the  ASGI HTTP Message format .", 
            "title": "The ASGI interface"
        }, 
        {
            "location": "/#http-scope", 
            "text": "An incoming HTTP request might instantiate an application with the following  scope :  {\n    'type': 'http.request',\n    'scheme': 'http',\n    'root_path': '',\n    'server': ('127.0.0.1', 8000),\n    'http_version': '1.1',\n    'method': 'GET',\n    'path': '/',\n    'headers': [\n        [b'host', b'127.0.0.1:8000'],\n        [b'user-agent', b'curl/7.51.0'],\n        [b'accept', b'*/*']\n    ]\n}", 
            "title": "HTTP Scope"
        }, 
        {
            "location": "/#http-messages", 
            "text": "The instance coroutine communicates back to the server by sending messages to the  send  coroutine.  await send({\n    'type': 'http.request.start',\n    'status': 200,\n    'headers': [\n        [b'content-type', b'text/plain'],\n    ]\n})\nawait send({\n    'type': 'http.request.body',\n    'body': b'Hello, world!',\n})", 
            "title": "HTTP Messages"
        }, 
        {
            "location": "/#requests-responses", 
            "text": "Here's an example that displays the method and path used in the incoming request:  class EchoMethodAndPath():\n    def __init__(self, scope):\n        self.scope = scope\n\n    async def __call__(self, recieve, send):\n        body = 'Received %s request to %s' % (self.scope['method'], self.scope['path'])\n        await send({\n            'http.response.start',\n            'status': 200,\n            'headers': [\n                [b'content-type', b'text/plain'],\n            ]\n        })\n        await send({\n            'type': 'http.response.body',\n            'body': body.encode('utf-8'),\n        })", 
            "title": "Requests &amp; responses"
        }, 
        {
            "location": "/#reading-the-request-body", 
            "text": "You can stream the request body without blocking the asyncio task pool,\nby fetching messages from the  receive  coroutine.  class EchoBody():\n    def __init__(self, scope):\n        self.scope = scope\n\n    async def read_body(self, receive):\n         \n        Read and return the entire body from an incoming ASGI message.\n         \n        body = b''\n        more_body = True\n\n        while more_body:\n            message = await receive()\n            body += message.get('body', b'')\n            more_body = message.get('more_body', False)\n\n        return body\n\n\n    async def __call__(self, receive, send):\n        body = await self.read_body(receive)\n        await send({\n            'http.response.start',\n            'status': 200,\n            'headers': [\n                [b'content-type', b'text/plain'],\n            ]\n        })\n        await send({\n            'type': 'http.response.body',\n            'body': body,\n        })", 
            "title": "Reading the request body"
        }, 
        {
            "location": "/#streaming-responses", 
            "text": "You can stream responses by sending multiple  http.response.body  messages to\nthe  send  coroutine.  class StreamResponse():\n    def __init__(self, scope):\n        self.scope = scope\n\n    async def __call__(self, receive, send):\n        body = await self.read_body(receive)\n        await send({\n            'http.response.start',\n            'status': 200,\n            'headers': [\n                [b'content-type', b'text/plain'],\n            ]\n        })\n        for chunk in [b'Hello', b', ', b'world!']\n            await send({\n                'type': 'http.response.body',\n                'body': chunk,\n                'more_body': True\n            })\n        await send({\n            'type': 'http.response.body',\n            'body': b'',\n        })", 
            "title": "Streaming responses"
        }, 
        {
            "location": "/#alternative-asgi-servers", 
            "text": "The first ASGI server implementation, originally developed to power Django Channels,\nis  the Daphne webserver .  It is run widely in production, and supports HTTP/1.1, HTTP/2, and WebSockets.  Any of the example applications given here can equally well be run using  daphne  instead.  $ pip install daphne\n$ daphne app:App", 
            "title": "Alternative ASGI servers"
        }
    ]
}